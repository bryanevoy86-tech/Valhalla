# services/api/app/routers/freeze_events.py

from __future__ import annotations

from typing import Any

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.exc import OperationalError, ProgrammingError
from sqlalchemy.orm import Session

from app.core.db import get_db
from app.freeze.models import FreezeEvent
from app.schemas.freeze_events import FreezeEventList, FreezeEventRead

router = APIRouter(
    prefix="/admin/freeze_events",
    tags=["Admin", "Freeze Events"],
)


def _handle_db_error(exc: Exception) -> None:
    """
    Convert a missing-table / incompatible-schema error into a clean HTTP 500
    with a helpful message instead of crashing the whole app.
    """
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail=(
            "freeze_events table is not available or has an incompatible schema. "
            "Ensure Postgres migrations have been applied in your production DB. "
            f"Original error: {exc}"
        ),
    )


@router.get(
    "",
    response_model=FreezeEventList,
    summary="List freeze events",
    description=(
        "Paginated list of freeze events generated by the scheduler or Heimdall. "
        "Primarily intended for admin / ops dashboards."
    ),
)
def list_freeze_events(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0, description="Number of records to skip (for pagination)."),
    limit: int = Query(
        50, ge=1, le=200, description="Maximum number of records to return."
    ),
    severity: str | None = Query(
        default=None,
        description="Optional severity filter (info, warn, critical).",
    ),
    event_type: str | None = Query(
        default=None,
        description="Optional event_type filter (e.g. 'liquidity', 'policy_violation').",
    ),
) -> FreezeEventList:
    try:
        query = db.query(FreezeEvent)

        if severity:
            query = query.filter(FreezeEvent.severity == severity)

        if event_type:
            query = query.filter(FreezeEvent.event_type == event_type)

        query = query.order_by(FreezeEvent.created_at.desc())

        total = query.count()
        items = query.offset(skip).limit(limit).all()
    except (ProgrammingError, OperationalError) as exc:
        _handle_db_error(exc)

    return FreezeEventList(
        total=total,
        items=items,
    )


@router.get(
    "/{freeze_id}",
    response_model=FreezeEventRead,
    summary="Get a single freeze event",
    description="Fetch details for a single freeze event by ID.",
)
def get_freeze_event(
    freeze_id: int,
    db: Session = Depends(get_db),
) -> FreezeEventRead:
    try:
        event = db.query(FreezeEvent).filter(FreezeEvent.id == freeze_id).first()
    except (ProgrammingError, OperationalError) as exc:
        _handle_db_error(exc)

    if not event:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Freeze event with id={freeze_id} not found.",
        )

    # Ensure payload is always a dict-or-None
    if hasattr(event, "to_safe_payload"):
        event.payload = event.to_safe_payload()  # type: ignore[assignment]

    return event
